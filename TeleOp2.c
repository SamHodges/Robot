#pragma config(Motor,  port1,           rightDrive,    tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftDrive,     tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float gain = 0.8;
float throttle;
float turn;
float tempLeft;
float tempRight;
float leftMotor;
float rightMotor;
int threshold = 5;

float error;
float setpoint;
float currPos;
float Kp;
float motorOutput;
float sum;
float Ki;
float lastError;
float dif;
float Kd;


task moveArm()
/*
1) calculate error term = setpoint - actual
2) motor value = Kp*error
3) clamp values
	if motorValue> 127
		motorValue = 127;
	else if motorValue < -127
		motor = -127;
function sensor(int x)
	return 4950 = x;
*/
{

	Kp = 0.5;
	Ki = 0.00001;
	/*Good Ki: 0.000005; 7 D in a W*/
	Kd = 1;
	sum = 0;
	lastError = 0;
	/*
	Agressive: 10
	Too low (going up): 0.05
	*/
	while(true){
	currPos = SensorValue[in8];
	error = setpoint - currPos;
	dif = error - lastError;

	if(error < 400 && error > -400 || setpoint < 3700){
	sum+=error;
		}
	lastError = error;


	motorOutput = Kp*error+ Ki*sum + Kd*dif;

	if (motorOutput > 127){
		motorOutput = 127;
		}

	else if(motorOutput < -127){
		motorOutput = -127;
		}

	motor[armMotor] = motorOutput;


	wait1Msec(10);
	}
}

float driveSkim(float f){
  /*if(f>127) return - (f - 127);
  else if (f < -127) return -(f + 127);
  else return 0;*/
  if (f > 127) return - (f - 127) * gain;
  else if (f < -127) return - (f + 127) * gain;
  else return 0;
}



task driveArcade(){
  while(true){
    throttle = vexRT[Ch3];
    turn = vexRT[Ch1];

    if (throttle < threshold && throttle > -threshold) throttle = 0;
    if (turn < threshold && turn > -threshold) turn = 0;

    tempLeft = throttle + turn;
    tempRight = throttle - turn;

    leftMotor = tempLeft + driveSkim(tempRight);
    rightMotor = tempRight + driveSkim(tempLeft);

    motor[leftDrive] = leftMotor;
    motor[rightDrive] = rightMotor;
    wait1Msec(20);
}
}

task changeArmSetpoint(){
	while(true){
		if( vexRT[Btn5U] == 1 ){ /*if it is 1, then it is pressed*/
  		setpoint -= 30;  /*up*/
  		wait10Msec(2); /*just for testing the button bounce*/
  		}
  	else if(vexRT[Btn5D] == 1 ) {
  		setpoint += 30;  /*down*/
  		wait10Msec(2);
  		}
  	else if(vexRT[Btn6U] == 1){
  		setpoint = 3975;
  	}
  	else if (vexRT[Btn6D] == 1){
  		setpoint = 800;
  	}
  	wait1Msec(20);

}
}

task claw(){
	while(true){
		if( vexRT[Btn8U] == 1 ){ /*if it is 1, then it is pressed*/
  		  /*close*/
  		  motor[clawMotor] = 67;
  		  wait1Msec(75);

  		}
  	else if( vexRT[Btn8R] == 1 ){ /*if it is 1, then it is pressed*/
  		/*open*/
  		motor[clawMotor] = -67;
  		  wait1Msec(75);
  		}
  	motor[clawMotor] = 0;


  wait1Msec(20);

}
}


task main(){
  startTask(moveArm);
  startTask(changeArmSetpoint);
  startTask(driveArcade);
  startTask(claw);

  setpoint = 3580;
	while(true) {



			wait1Msec(20);
	}
}
