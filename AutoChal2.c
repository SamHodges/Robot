#pragma config(Sensor, in8,    Pontentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl4,  Bumper,         sensorTouch)
#pragma config(Motor,  port1,           Right,         tmotorVex393_HBridge, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port6,           Claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          Left,          tmotorVex393_HBridge, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float error;
float setpoint;
float currPos;
float Kp;
float motorOutput;
float sum;
float Ki;
float lastError;
float dif;
float Kd;
float stopSum;
bool trash1;

void armPID(float setnum, bool trash){
trash1 = trash;
setpoint = setnum;
Kp = 0.1;
/*0.01 too low, 0.1 works but does have oscillation*/
	Ki = 0.000005;
	/*Good Ki: 0.000005; 7 D in a W, try I super low? 0.00002 = old*/
	Kd = 5;
	sum = 0;
	lastError = 0;
	stopSum = 0;
	/*
	Agressive: 10
	Too low (going up): 0.05
	*/
	while(stopSum < 1000){
	currPos = SensorValue[in8];
	error = setpoint - currPos;
	dif = error - lastError;

	if(error < 400 && error > -400){
	sum+=error;
		}

	motorOutput = Kp*error + Ki*sum + Kd*dif;

	if (motorOutput > 127){
		motorOutput = 127;
		}

	else if(motorOutput < -127){
		motorOutput = -127;
		}
	if(currPos > 3500 && currPos < setpoint && motorOutput>100){
		motorOutput = -10;
}

	motor[Arm] = motorOutput;
	lastError = error;

	if(error < 25 && error > -25){
	stopSum += 1;
}

	if(trash1 == true){
		if(currPos <setpoint){
	stopSum =1001;
		motor[Arm] = 10;
}
}

	}
}

void close(){
	motor[Claw] = 67;
	wait1Msec(100);
	motor[Claw] = 20;
	wait1Msec(3000);
}

void open(){
	motor[Arm] = 10;
	motor[Claw] = -67;
	wait1Msec(300);
	motor[Claw] = 0;
}



task main(){
	/*3975*/
	armPID(3975, false);
	close();
	armPID(800, true);
	open();
}
